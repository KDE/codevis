// ct_lvtplg_pythonlibrarydispatcher.cpp                             -*-C++-*-

/*
// Copyright 2023 Codethink Ltd <codethink@codethink.co.uk>
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/

#include <ct_lvtplg_pythonlibrarydispatcher.h>

namespace Codethink::lvtplg {

// Automatically generated by generate_python_hook_bindings.py and available in the <build>/lvtplg/ folder
#include <ct_lvtplg_hookbindings.inc.cpp>

PythonLibraryDispatcher::PyResolveContext::~PyResolveContext()
{
    PythonLibraryDispatcher::PyResolveContext::activeModule = nullptr;
}

std::unique_ptr<AbstractLibraryDispatcher::ResolveContext>
PythonLibraryDispatcher::resolve(std::string const& functionName)
{
    return std::make_unique<PyResolveContext>(this->pyModule, functionName);
}

std::string PythonLibraryDispatcher::fileName()
{
    py::gil_scoped_acquire _;
    std::filesystem::path pluginPath = this->pyModule.attr("__file__").cast<std::string>();
    return pluginPath.generic_string();
}

bool PythonLibraryDispatcher::isValidPlugin(QDir const& pluginDir)
{
    auto pluginName = pluginDir.dirName();
    return (pluginDir.exists("metadata.json") && pluginDir.exists("README.md") && pluginDir.exists(pluginName + ".py"));
}

std::unique_ptr<AbstractLibraryDispatcher> PythonLibraryDispatcher::loadSinglePlugin(QDir const& pluginDir)
{
    py::gil_scoped_acquire _;

    auto pluginName = pluginDir.dirName().toStdString();
    auto pyLib = std::make_unique<PythonLibraryDispatcher>();

    auto pySys = py::module_::import("sys");
    pySys.attr("path").attr("append")(pluginDir.path().toStdString());
    try {
        pyLib->pyModule = py::module_::import(pluginName.c_str());
        pyLib->pluginFolder = pluginDir.path().toStdString();
    } catch (py::error_already_set const& e) {
        // Setting the sys.attr can also cause another throw.
        std::cout << "Invalid plugin (" << pluginDir.path().toStdString() << "): " << e.what() << "\n";
        try {
            // Could not load python module - Cleanup sys path and early return.
            pySys.attr("path").attr("remove")(pluginDir.path().toStdString());
        } catch (std::exception& e) {
            std::cout << "+ Cleanup error: " << e.what() << "\n";
        }
        return nullptr;
    }

    return pyLib;
}

void PythonLibraryDispatcher::reload()
{
    py::gil_scoped_acquire _;
    pyModule.reload();
}

// This method assumes the plugin has already been cleaned up (e.g.: hookTeardown has been called)
void PythonLibraryDispatcher::unload()
{
    py::gil_scoped_acquire _;

    try {
        auto pySys = py::module_::import("sys");
        pySys.attr("path").attr("remove")(pluginFolder.c_str());
    } catch (std::exception& e) {
        std::cout << "Error unloading python plugin";
    }
}

} // namespace Codethink::lvtplg
