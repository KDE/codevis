/*
    SPDX-FileCopyrightText: 2021 Tomaz Canabrava <tcanabrava@kde.org>
    SPDX-License-Identifier: MIT
*/

#include "common/dump_common.h"
#include "common/string_helpers.h"

#include <QList>
#include <string>
#include <iostream>


// Transforms a metaProperty into a `Parent()->OtherParent()->Property()", callable, string.
std::string get_call_chain(std::shared_ptr<MetaProperty> property, std::string suffix) {
    std::string callchain;
    auto tmp = property->parent;
        if (tmp && tmp->parent) {
        while (tmp->parent) {
            std::string s = decapitalize(tmp->name, 0) + "()->";
            callchain.insert(0, s);
            tmp = tmp->parent;
        }
    }

    callchain.append(property->name + suffix + "()");
    return callchain;
}

void dump_headers(std::ofstream& f, const std::vector<MetaInclude>& includes) {
  for (auto include : includes) {
    if (include.is_global) {
      f << "#include <" << include.name << '>' << std::endl;
    } else {
      f << "#include \"" << include.name << '"' << std::endl;
    }
  }
}

void dump_source_get_methods(std::ofstream& f, MetaClass *top)
{
  // get - methods.
  for (auto &&p : top->properties) {
    f << p->type << ' ' << top->name << "::" << p->name << "() const"
         << std::endl;
    f << '{' << std::endl;
    f << "\treturn _" << p->name << ';' << std::endl;
    f << '}' << std::endl;
    f << std::endl;
  }
}

void dump_source_set_methods(std::ofstream& f, MetaClass *top, bool useRules) {
  for (auto &&p : top->properties) {
    f << "void " << top->name << "::set" << capitalize(p->name, 0) << '(';
        dump_parameter(f, p);
    f << ")" << std::endl;
    f << "{" << std::endl;
    f << "\tif (_" << p->name << "==" << "value) {" << std::endl;
    f << "\t\treturn;" << std::endl;
    f << "\t}" << std::endl;

    if (useRules) {
        f << "\tif (" << p->name << "Rule && !" << p->name << "Rule(value)) {" << std::endl;
        f << "\t\treturn;" << std::endl;
        f << "\t}" << std::endl;
    }

    f << "\t_" << p->name << " = value;" << std::endl;
    f << "\tQ_EMIT " << p->name << "Changed(value);" << std::endl;
    f << "}" << std::endl;
    f << std::endl;
  }
}

void dump_parameter(std::ofstream& file, const std::shared_ptr<MetaProperty>& p)
{
    if (pass_as_const_ref(p->type)) {
        file << "const " << p->type << "&";
    } else {
        file << p->type;
    }

    file << " value";
}

void dump_header_properties(std::ofstream &file, const std::vector<std::shared_ptr<MetaProperty>> &properties, bool useRules) {
  if (!properties.size())
    return;

  for (auto &&p : properties) {
    file << "\t" << p->type << " " << p->name << "() const;" << std::endl;
    if (useRules) {
        file << "\tvoid set" << capitalize(p->name, 0) << "Rule(std::function<bool("
            << p->type << ")> rule);" << std::endl;
    }
    file << "\t" << p->type << " " << p->name << "Default() const;" << std::endl;
  }

  file << std::endl << "public:" << std::endl;
  for (auto &&p : properties) {
    file << "\t Q_SLOT void set" << capitalize(p->name, 0) << "(";
        dump_parameter(file, p);
    file << ");" << std::endl;
  }

  for (auto &&p : properties) {
    file << "\t Q_SIGNAL void " << p->name << "Changed(";
        dump_parameter(file, p);
    file << ");" << std::endl;
  }

  file << std::endl << "private:" << std::endl;
  for (auto &&p : properties) {
    file << "\t" << p->type << " _" << p->name << ";" << std::endl;
    if (useRules) {
        file << "\tstd::function<bool(" << p->type << ")> " << p->name << "Rule;" << std::endl;
    }
  }
}

void dump_header_q_properties(std::ofstream &file, const std::vector<std::shared_ptr<MetaProperty>> &properties)
{
    for (auto &&p : properties) {
    file << "\tQ_PROPERTY(" << p->type << " "
         << camel_case_to_underscore(p->name) << " READ " << p->name
         << " WRITE set" << capitalize(p->name, 0) << " NOTIFY " << p->name
         << "Changed)" << std::endl;
  }
}

bool pass_as_const_ref(const std::string& type) {
    for(const auto simple_type : {"int", "bool", "char", "double", "float", "qreal", "size_t", "QChar"}) {
        if (type == simple_type) {
            return false;
        }
    }
    // This is probably false but will have a ok rate of false positives.
    return true;
}

void dump_notice(std::ofstream& f)
{
    f << "// DO NOT EDIT THIS FILE" << std::endl;
    f << "// This file was automatically generated by configuration-parser" << std::endl;
    f << "// There will be a .conf file somewhere which was used to generate this file" << std::endl;
    f << "// See https://github.com/tcanabrava/configuration-parser" << std::endl;
    f << std::endl;
}

